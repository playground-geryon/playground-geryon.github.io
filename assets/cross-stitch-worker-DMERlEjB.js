(function(){"use strict";const O=t=>t.toString(16).padStart(2,"0"),F=(t,s,h)=>`#${O(t)}${O(s)}${O(h)}`,T=(t,s)=>{const n=255/(2**s-1),u=Math.round(t/n)*n;return Math.max(0,Math.min(255,Math.round(u)))},ot=(t,s)=>{if(s===0)return t;const h=parseInt(t.slice(1,3),16),n=parseInt(t.slice(3,5),16),u=parseInt(t.slice(5,7),16),e=s===8?{r:3,g:3,b:2}:s===16?{r:5,g:6,b:5}:{r:8,g:8,b:8},a=T(h,e.r),M=T(n,e.g),f=T(u,e.b);return F(a,M,f)},at=(t,s)=>s[t]??t,$=t=>({r:parseInt(t.slice(1,3),16),g:parseInt(t.slice(3,5),16),b:parseInt(t.slice(5,7),16)}),L=(t,s)=>(t.r-s.r)**2+(t.g-s.g)**2+(t.b-s.b)**2,rt=(t,s)=>{const h=t.map(e=>({...$(e.hex),count:e.count}));if(!h.length)return[];let n=[{items:h}];const u=e=>{if(e.items.length<=1)return[e];const a=["r","g","b"].map(d=>{const l=e.items.map(x=>x[d]);return Math.max(...l)-Math.min(...l)}),M=a.indexOf(Math.max(...a)),f=["r","g","b"][M],c=[...e.items].sort((d,l)=>d[f]-l[f]),r=c.reduce((d,l)=>d+l.count,0);let i=0,g=0;for(;g<c.length&&(i+=c[g].count,!(i>=r/2));g++);if(g<=0||g>=c.length-1){const d=Math.floor(c.length/2);return[{items:c.slice(0,d)},{items:c.slice(d)}]}return[{items:c.slice(0,g+1)},{items:c.slice(g+1)}]};for(;n.length<s;){n.sort((f,c)=>c.items.length-f.items.length);const e=n.shift();if(!e)break;if(e.items.length<=1){n.push(e);break}const[a,M]=u(e);if(n.push(a),n.push(M),n.length>=s)break}return n.map(e=>{const a=e.items.reduce((r,i)=>r+i.count,0);if(!a)return null;const M=Math.round(e.items.reduce((r,i)=>r+i.r*i.count,0)/a),f=Math.round(e.items.reduce((r,i)=>r+i.g*i.count,0)/a),c=Math.round(e.items.reduce((r,i)=>r+i.b*i.count,0)/a);return{hex:F(M,f,c),count:a,percent:0}}).filter(e=>!!e).sort((e,a)=>a.count-e.count)},ct=async t=>{if(t.startsWith("data:image/png"))return t;const h=await(await fetch(t)).blob(),n=await createImageBitmap(h),u=new OffscreenCanvas(n.width,n.height),e=u.getContext("2d");if(!e)return t;e.drawImage(n,0,0);const a=await u.convertToBlob({type:"image/png"});return new FileReaderSync().readAsDataURL(a)},it=async t=>{const h=await(await fetch(t)).blob();return createImageBitmap(h)},lt=async(t,s)=>{const{dataUrl:h,colCountInput:n,bitDepth:u,useOriginalSize:e,overrides:a,cellOverrides:M,paletteSize:f}=t,c=await ct(h),r=await it(c),i=e?1:Math.min(800/Math.max(r.width,r.height),1),g=Math.max(1,Math.round(r.width*i)),d=Math.max(1,Math.round(r.height*i)),l=Math.max(1,Math.min(Math.round(n),g)),x=Math.max(1,Math.round(d/g*l)),N=new OffscreenCanvas(g,d).getContext("2d",{willReadFrequently:!0});if(!N)throw new Error("캔버스를 초기화할 수 없습니다.");N.drawImage(r,0,0,g,d);const U=Math.max(1,Math.floor(800/Math.max(l,x))),R=l*U,E=x*U,K=new OffscreenCanvas(R,E),A=K.getContext("2d");if(!A)throw new Error("캔버스를 초기화할 수 없습니다.");const z=A.createImageData(R,E),C=new Map,P=[],ht="#ffffff",Y=g/l,j=d/x,G=R/l,J=E/x;s(10),P.length=0,C.clear();const ut=x*l;for(let o=0;o<x;o++){for(let m=0;m<l;m++){const I=Math.floor(m*Y),S=Math.floor(o*j),q=Math.min(g,Math.floor((m+1)*Y)),X=Math.min(d,Math.floor((o+1)*j)),H=Math.max(1,q-I),B=Math.max(1,X-S),b=N.getImageData(I,S,H,B).data,D=new Map;for(let y=0;y<b.length;y+=4){if(b[y+3]===0)continue;const st=b[y]<<16|b[y+1]<<8|b[y+2];D.set(st,(D.get(st)??0)+1)}let w=-1,W=0;D.forEach((y,nt)=>{y>W&&(W=y,w=nt)});const mt=W>0?F(w>>16&255,w>>8&255,w&255):ht,_=ot(mt,u),V=Math.round(m*G),Z=Math.round(o*J),ft=Math.round((m+1)*G),Mt=Math.round((o+1)*J),tt=Math.max(1,ft-V),et=Math.max(1,Mt-Z);P.push({key:`${m},${o}`,x0:V,y0:Z,cellPixW:tt,cellPixH:et,hex:_}),C.set(_,(C.get(_)??0)+tt*et)}const p=(o+1)*l/ut;s(Math.min(90,10+p*80))}A.putImageData(z,0,0);const Q=R*E;let v=Array.from(C.entries()).map(([o,p])=>({hex:o,count:p,percent:0})),k=[];f>0&&v.length>f&&(v=rt(v,f),k=v.map(o=>({hex:o.hex,rgb:$(o.hex)})));const gt=o=>{if(!k.length)return o;const p=$(o);let m=k[0],I=L(p,m.rgb);for(const S of k.slice(1)){const q=L(p,S.rgb);q<I&&(I=q,m=S)}return m.hex};C.clear(),P.forEach(({key:o,x0:p,y0:m,cellPixW:I,cellPixH:S,hex:q})=>{const X=k.length?gt(q):q,H=M[o],B=H||at(X,a);C.set(B,(C.get(B)??0)+I*S);for(let b=0;b<S;b++)for(let D=0;D<I;D++){const w=((m+b)*R+(p+D))*4;z.data[w]=parseInt(B.slice(1,3),16),z.data[w+1]=parseInt(B.slice(3,5),16),z.data[w+2]=parseInt(B.slice(5,7),16),z.data[w+3]=255}}),A.putImageData(z,0,0),v=Array.from(C.entries()).map(([o,p])=>({hex:o,count:p,percent:Number((p/Q*100).toFixed(2))})).sort((o,p)=>p.count-o.count);const dt=await K.convertToBlob({type:"image/png"}),pt=new FileReaderSync().readAsDataURL(dt);return s(100),{pixelatedSrc:pt,colors:v,totalPixels:Q,uniqueCount:v.length,originalSize:{width:r.width,height:r.height},renderedSize:{width:R,height:E},colCount:l,rowCount:x,safeDataUrl:c}};self.onmessage=async t=>{const{id:s,payload:h}=t.data;try{const n=await lt(h,e=>{const a={id:s,type:"progress",value:e};self.postMessage(a)}),u={id:s,type:"result",payload:{pixelatedSrc:n.pixelatedSrc,colors:n.colors,totalPixels:n.totalPixels,uniqueCount:n.uniqueCount,originalSize:n.originalSize,renderedSize:n.renderedSize,colCount:n.colCount,rowCount:n.rowCount}};self.postMessage(u)}catch(n){const u={id:s,type:"error",message:n instanceof Error?n.message:"이미지 처리 중 오류가 발생했습니다."};self.postMessage(u)}}})();
